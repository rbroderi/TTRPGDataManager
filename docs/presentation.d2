text: |md
	# TTRPG Data Manager<br/>Final Project

	<h2 style="margin:0;border-bottom:none;">Database CRUD Project</h2>
	|
layers: {
	1: {
		text: |md
			<h2 style="margin:0;border-bottom:none;">1</h2>

			# Problem & Users
		|
	}
	2: {
		text: |md
			## Pain Points
			- Campaign notes splintered across docs, spreadsheets, and ad-hoc images make session prep slow.
			- GMs lack a shared source of truth for NPC traits, locations, factions, and ongoing encounters.
			- Hard to find the information in a quick manner.

			## Target Users
			- GM:
			- Story Teller / Author:
			- They perform CRUD operations inside the GUI
			- Adds portraits, relationships, and faction notes.
		|
	}
	3: {
		text: |md
			<h2 style="margin:0;border-bottom:none;">2</h2>

			# Data Model (ERD)
		|
	}
	4: {
		text: |md
			# Data Model (ERD)

			- Campaign is the root; every NPC, Location, Encounter, and Faction points back via FK.
			- Join tables capture many-to-many edges:
				- `faction_members` maps factions ↔ NPCs with notes.
				- `encounter_participants` maps encounters ↔ NPCs with per-session notes.
				- `relationship` is a self-join storing NPC-to-NPC ties.
			- Enums (gender, alignment, location type, campaign status) enforce consistent vocabulary.
			- Diagram exported from `docs/erd.uml` → `docs/images/erd.png`.	|
	}
	5: {
		text: |md
			<h2 style="margin:0;border-bottom:none;">3</h2>

			# Key Schema Highlights
		|
	}
	6: {
		text: |md
			# Key Schema Highlights

			- **Primary Keys:** surrogate `INT AUTO_INCREMENT` on core tables; composite PKs on<br/>join tables to prevent duplicates.
			- **Foreign Keys:** all relationships declared explicitly in `data/db.ddl`; no<br/>implicit cascades.
			- **Referential Constraints:** `ON DELETE CASCADE/RESTRICT` and `ON UPDATE CASCADE` live<br/> in the DDL so engines clean up or block as intended.
			- **Cascades:** are declared in the DDL (`ON DELETE CASCADE/RESTRICT`) so the database<br/> enforces cleanup directly.
			  - **Updates:** cascade as well (`ON UPDATE CASCADE`), so renaming a campaign/location<br/> ripples to dependents without manual scripts.
			- **Validation:** enums + JSON columns + beartype/mypy provide both DB- and app-level<br/> guarantees.
		|
	}
	7: {
		text: |md
			<h2 style="margin:0;border-bottom:none;">4</h2>

			# Live Demo
		|
	}
	8: {
		text: |md
			# Live Demo (Forms)

			1. Launch GUI → select campaign in menu bar.
			2. NPC form: fill data, alignment etc., upload portrait → Save.
			3. Faction drawer: assign NPC to faction; observe instant list refresh.
			4. Encounter form: choose location/date, attach art, then open Participants dialog to add the NPC with GM notes.
		|
	}
	9: {
		text: |md
			# Live Demo (JOIN Report)

			- Use the Encounter detail pane to show combined view:
				- Encounter metadata + linked location + campaign status.
				- Participant table = JOIN of `encounter_participants`, `npc`, and `faction_members`.
		|
	}
	10: {
		text: |md
			<h2 style="margin:0;border-bottom:none;">5</h2>

			# Architecture & Lessons Learned
		|
	}
	11: {
		text: |md
			# Architecture

			- **UI Layer:** CustomTkinter (`gui.py`, `widgets.py`) + async helpers for LLM dialogs.
			- **Logic Layer:** `logic.py` / `llmrunner.py` orchestrate validation, data binding, and background tasks.
			- **Data Layer:** `db.py` centralizes SQLAlchemy models, DDL loaders (SQLAlchemy + mysql-connector).
			- **Tooling:** `uv` for deps, `structlog` for JSON logs, `ruff/mypy/pyright` for static linting/type checking.
		|
	}
	12: {
		text: |md
			# Lessons Learned
			- Automate screenshots + sample data so demos stay deterministic.
		|
	}
}
